(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[931],{5515:function(e,t,i){Promise.resolve().then(i.bind(i,354))},354:function(e,t,i){"use strict";i.r(t),i.d(t,{default:function(){return D}});var n=i(7437),r=i(2265),a=i(1538),o=i(2218),s=i(4839),l=i(6164);function d(){for(var e=arguments.length,t=Array(e),i=0;i<e;i++)t[i]=arguments[i];return(0,l.m6)((0,s.W)(t))}let m=(0,o.j)("inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50",{variants:{variant:{default:"bg-primary text-primary-foreground hover:bg-primary/90",destructive:"bg-destructive text-destructive-foreground hover:bg-destructive/90",outline:"border border-input bg-background hover:bg-accent hover:text-accent-foreground",secondary:"bg-secondary text-secondary-foreground hover:bg-secondary/80",ghost:"hover:bg-accent hover:text-accent-foreground",link:"text-primary underline-offset-4 hover:underline"},size:{default:"h-10 px-4 py-2",sm:"h-9 rounded-md px-3",lg:"h-11 rounded-md px-8",icon:"h-10 w-10"}},defaultVariants:{variant:"default",size:"default"}}),c=r.forwardRef((e,t)=>{let{className:i,variant:r,size:o,asChild:s=!1,...l}=e,c=s?a.g7:"button";return(0,n.jsx)(c,{className:d(m({variant:r,size:o,className:i})),ref:t,...l})});c.displayName="Button";var p=i(1246),u=i(7592),g=i(2468),f=i(8165);let h=p.fC,x=p.xz;p.ZA,p.Uv,p.Tr;let y=p.Ee;r.forwardRef((e,t)=>{let{className:i,inset:r,children:a,...o}=e;return(0,n.jsxs)(p.fF,{ref:t,className:d("flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent data-[state=open]:bg-accent",r&&"pl-8",i),...o,children:[a,(0,n.jsx)(u.Z,{className:"ml-auto h-4 w-4"})]})}).displayName=p.fF.displayName,r.forwardRef((e,t)=>{let{className:i,...r}=e;return(0,n.jsx)(p.tu,{ref:t,className:d("z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",i),...r})}).displayName=p.tu.displayName;let b=r.forwardRef((e,t)=>{let{className:i,sideOffset:r=4,...a}=e;return(0,n.jsx)(p.Uv,{children:(0,n.jsx)(p.VY,{ref:t,sideOffset:r,className:d("z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",i),...a})})});b.displayName=p.VY.displayName,r.forwardRef((e,t)=>{let{className:i,inset:r,...a}=e;return(0,n.jsx)(p.ck,{ref:t,className:d("relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",r&&"pl-8",i),...a})}).displayName=p.ck.displayName,r.forwardRef((e,t)=>{let{className:i,children:r,checked:a,...o}=e;return(0,n.jsxs)(p.oC,{ref:t,className:d("relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",i),checked:a,...o,children:[(0,n.jsx)("span",{className:"absolute left-2 flex h-3.5 w-3.5 items-center justify-center",children:(0,n.jsx)(p.wU,{children:(0,n.jsx)(g.Z,{className:"h-4 w-4"})})}),r]})}).displayName=p.oC.displayName;let v=r.forwardRef((e,t)=>{let{className:i,children:r,...a}=e;return(0,n.jsxs)(p.Rk,{ref:t,className:d("relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",i),...a,children:[(0,n.jsx)("span",{className:"absolute left-2 flex h-3.5 w-3.5 items-center justify-center",children:(0,n.jsx)(p.wU,{children:(0,n.jsx)(f.Z,{className:"h-2 w-2 fill-current"})})}),r]})});v.displayName=p.Rk.displayName,r.forwardRef((e,t)=>{let{className:i,inset:r,...a}=e;return(0,n.jsx)(p.__,{ref:t,className:d("px-2 py-1.5 text-sm font-semibold",r&&"pl-8",i),...a})}).displayName=p.__.displayName,r.forwardRef((e,t)=>{let{className:i,...r}=e;return(0,n.jsx)(p.Z0,{ref:t,className:d("-mx-1 my-1 h-px bg-muted",i),...r})}).displayName=p.Z0.displayName;var k=i(28);let C=r.forwardRef((e,t)=>{let{className:i,...r}=e;return(0,n.jsxs)(k.fC,{ref:t,className:d("relative flex w-full touch-none select-none items-center",i),...r,children:[(0,n.jsx)(k.fQ,{className:"relative h-2 w-full grow overflow-hidden rounded-full bg-secondary",children:(0,n.jsx)(k.e6,{className:"absolute h-full bg-primary"})}),(0,n.jsx)(k.bU,{className:"block h-5 w-5 rounded-full border-2 border-primary bg-background ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50"})]})});C.displayName=k.fC.displayName;let O=r.forwardRef((e,t)=>{let{className:i,...r}=e;return(0,n.jsx)("div",{ref:t,className:d("rounded-lg border bg-card text-card-foreground shadow-sm",i),...r})});O.displayName="Card";let w=r.forwardRef((e,t)=>{let{className:i,...r}=e;return(0,n.jsx)("div",{ref:t,className:d("flex flex-col space-y-1.5 p-6",i),...r})});w.displayName="CardHeader";let S=r.forwardRef((e,t)=>{let{className:i,...r}=e;return(0,n.jsx)("h3",{ref:t,className:d("text-2xl font-semibold leading-none tracking-tight",i),...r})});S.displayName="CardTitle";let j=r.forwardRef((e,t)=>{let{className:i,...r}=e;return(0,n.jsx)("p",{ref:t,className:d("text-sm text-muted-foreground",i),...r})});j.displayName="CardDescription";let N=r.forwardRef((e,t)=>{let{className:i,...r}=e;return(0,n.jsx)("div",{ref:t,className:d("p-6 pt-0",i),...r})});N.displayName="CardContent",r.forwardRef((e,t)=>{let{className:i,...r}=e;return(0,n.jsx)("div",{ref:t,className:d("flex items-center p-6 pt-0",i),...r})}).displayName="CardFooter";var T=i(3304),z=i(4697);let E=T.fC,R=T.xz,I=T.h_;T.x8;let A=r.forwardRef((e,t)=>{let{className:i,...r}=e;return(0,n.jsx)(T.aV,{ref:t,className:d("fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",i),...r})});A.displayName=T.aV.displayName;let q=r.forwardRef((e,t)=>{let{className:i,children:r,...a}=e;return(0,n.jsxs)(I,{children:[(0,n.jsx)(A,{}),(0,n.jsxs)(T.VY,{ref:t,className:d("fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",i),...a,children:[r,(0,n.jsxs)(T.x8,{className:"absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground",children:[(0,n.jsx)(z.Z,{className:"h-4 w-4"}),(0,n.jsx)("span",{className:"sr-only",children:"Close"})]})]})]})});q.displayName=T.VY.displayName;let P=e=>{let{className:t,...i}=e;return(0,n.jsx)("div",{className:d("flex flex-col space-y-1.5 text-center sm:text-left",t),...i})};P.displayName="DialogHeader";let M=r.forwardRef((e,t)=>{let{className:i,...r}=e;return(0,n.jsx)(T.Dx,{ref:t,className:d("text-lg font-semibold leading-none tracking-tight",i),...r})});M.displayName=T.Dx.displayName;let B=r.forwardRef((e,t)=>{let{className:i,...r}=e;return(0,n.jsx)(T.dk,{ref:t,className:d("text-sm text-muted-foreground",i),...r})});B.displayName=T.dk.displayName;let L=["en","fr","it","de","es","ja","no","sv","ua","ru"],H={bubble:{en:{title:"Bubble Sort",timeComplexity:"Time: O(n^2)",spaceComplexity:"Space: O(1)",description:"Bubble sort is a simple sorting algorithm that repeatedly steps through the list, compares adjacent elements and swaps them if they are in the wrong order. The pass through the list is repeated until the list is sorted."},fr:{title:"Bubble Sort",timeComplexity:"Temps : O(n^2)",spaceComplexity:"Espace : O(1)",description:"Le tri \xe0 bulles est un algorithme de tri simple qui parcourt \xe0 plusieurs reprises la liste, compare les \xe9l\xe9ments adjacents et les \xe9change s'ils sont dans le mauvais ordre. Le passage \xe0 travers la liste est r\xe9p\xe9t\xe9 jusqu'\xe0 ce que la liste soit tri\xe9e."},it:{title:"Bubble Sort",timeComplexity:"Tempo: O(n^2)",spaceComplexity:"Spazio: O(1)",description:"Il bubble sort \xe8 un algoritmo di ordinamento semplice che scorre ripetutamente la lista, confronta gli elementi adiacenti e li scambia se sono nell'ordine sbagliato. Il passaggio attraverso la lista viene ripetuto fino a quando la lista non \xe8 ordinata."},de:{title:"Bubble Sort",timeComplexity:"Zeit: O(n^2)",spaceComplexity:"Platz: O(1)",description:"Bubble Sort ist ein einfacher Sortieralgorithmus, der wiederholt durch die Liste geht, benachbarte Elemente vergleicht und sie vertauscht, wenn sie in der falschen Reihenfolge sind. Der Durchgang durch die Liste wird wiederholt, bis die Liste sortiert ist."},es:{title:"Bubble Sort",timeComplexity:"Tiempo: O(n^2)",spaceComplexity:"Espacio: O(1)",description:"El ordenamiento de burbuja es un algoritmo de ordenamiento simple que recorre repetidamente la lista, compara los elementos adyacentes y los intercambia si est\xe1n en el orden incorrecto. El recorrido a trav\xe9s de la lista se repite hasta que la lista est\xe1 ordenada."},ja:{title:"Bubble Sort",timeComplexity:"時間: O(n^2)",spaceComplexity:"空間: O(1)",description:"バブルソートは、リストを繰り返しステップして、隣接する要素を比較し、それらが間違った順序にある場合に入れ替える単純なソートアルゴリズムです。リストを通過する操作はリストがソートされるまで繰り返されます。"},no:{title:"Bubble Sort",timeComplexity:"Tid: O(n^2)",spaceComplexity:"Plass: O(1)",description:"Bubble sort er en enkel sorteringsalgoritme som gjentatte ganger g\xe5r gjennom listen, sammenligner tilst\xf8tende elementer og bytter dem hvis de er i feil rekkef\xf8lge. Gjennomgangen av listen gjentas til listen er sortert."},sv:{title:"Bubble Sort",timeComplexity:"Tid: O(n^2)",spaceComplexity:"Utrymme: O(1)",description:"Bubble sort \xe4r en enkel sorteringsalgoritm som upprepade g\xe5nger g\xe5r igenom listan, j\xe4mf\xf6r intilliggande element och byter dem om de \xe4r i fel ordning. Genomg\xe5ngen av listan upprepas tills listan \xe4r sorterad."},ua:{title:"Bubble Sort",timeComplexity:"Час: O(n^2)",spaceComplexity:"Місце: O(1)",description:"Сортування бульбашкою - це простий алгоритм сортування, який повторно проходить по списку, порівнює суміжні елементи та змінює їх місцями, якщо вони знаходяться в неправильному порядку. Прохід по списку повторюється до тих пір, поки список не буде відсортований."},ru:{title:"Bubble Sort",timeComplexity:"Время: O(n^2)",spaceComplexity:"Место: O(1)",description:"Сортировка пузырьком - это простой алгоритм сортировки, который многократно проходит по списку, сравнивает смежные элементы и меняет их местами, если они находятся в неправильном порядке. Проход по списку повторяется до тех пор, пока список не будет отсортирован."}},insertion:{en:{title:"Insertion Sort",timeComplexity:"Time: O(n^2)",spaceComplexity:"Space: O(1)",description:"Insertion sort is a simple sorting algorithm that builds the final sorted array one item at a time. It is much less efficient on large lists than more advanced algorithms such as quicksort, heapsort, or merge sort."},fr:{title:"Insertion Sort",timeComplexity:"Temps : O(n^2)",spaceComplexity:"Espace : O(1)",description:"Le tri par insertion est un algorithme de tri simple qui construit le tableau tri\xe9 final un \xe9l\xe9ment \xe0 la fois. Il est beaucoup moins efficace sur les grandes listes que des algorithmes plus avanc\xe9s comme le tri rapide, le tri par tas ou le tri fusion."},it:{title:"Insertion Sort",timeComplexity:"Tempo: O(n^2)",spaceComplexity:"Spazio: O(1)",description:"L'insertion sort \xe8 un algoritmo di ordinamento semplice che costruisce l'array ordinato finale un elemento alla volta. \xc8 molto meno efficiente su grandi liste rispetto ad algoritmi pi\xf9 avanzati come il quicksort, l'heapsort o il merge sort."},de:{title:"Insertion Sort",timeComplexity:"Zeit: O(n^2)",spaceComplexity:"Platz: O(1)",description:"Insertion Sort ist ein einfacher Sortieralgorithmus, der das endg\xfcltig sortierte Array ein Element nach dem anderen aufbaut. Es ist viel weniger effizient bei gro\xdfen Listen als fortschrittlichere Algorithmen wie Quicksort, Heapsort oder Mergesort."},es:{title:"Insertion Sort",timeComplexity:"Tiempo: O(n^2)",spaceComplexity:"Espacio: O(1)",description:"El ordenamiento por inserci\xf3n es un algoritmo de ordenamiento simple que construye la matriz ordenada final un elemento a la vez. Es mucho menos eficiente en listas grandes que algoritmos m\xe1s avanzados como el quicksort, el heapsort o el mergesort."},ja:{title:"Insertion Sort",timeComplexity:"時間: O(n^2)",spaceComplexity:"空間: O(1)",description:"挿入ソートは、最終的にソートされた配列を一度に1つの項目ずつ構築する単純なソートアルゴリズムです。クイックソート、ヒープソート、マージソートなどの高度なアルゴリズムよりも大きなリストでは効率が大幅に低下します。"},no:{title:"Insertion Sort",timeComplexity:"Tid: O(n^2)",spaceComplexity:"Plass: O(1)",description:"Insertion sort er en enkel sorteringsalgoritme som bygger den endelige sorterte matrisen ett element om gangen. Det er mye mindre effektivt p\xe5 store lister enn mer avanserte algoritmer som quicksort, heapsort eller mergesort."},sv:{title:"Insertion Sort",timeComplexity:"Tid: O(n^2)",spaceComplexity:"Utrymme: O(1)",description:"Insertion sort \xe4r en enkel sorteringsalgoritm som bygger den slutgiltiga sorterade matrisen ett element i taget. Det \xe4r mycket mindre effektivt p\xe5 stora listor \xe4n mer avancerade algoritmer som quicksort, heapsort eller mergesort."},ua:{title:"Insertion Sort",timeComplexity:"Час: O(n^2)",spaceComplexity:"Місце: O(1)",description:"Сортування вставкою - це простий алгоритм сортування, який будує остаточно відсортований масив по одному елементу за раз. Він набагато менш ефективний на великих списках, ніж більш просунуті алгоритми, такі як швидке сортування, сортування купою або сортування злиттям."},ru:{title:"Insertion Sort",timeComplexity:"Время: O(n^2)",spaceComplexity:"Место: O(1)",description:"Сортировка вставками - это простой алгоритм сортировки, который строит окончательно отсортированный массив по одному элементу за раз. Он гораздо менее эффективен на больших списках, чем более продвинутые алгоритмы, такие как быстрая сортировка, сортировка кучей или сортировка слиянием."}},merge:{en:{title:"Merge Sort",timeComplexity:"Time: O(n log n)",spaceComplexity:"Space: O(n)",description:"Merge sort is an efficient, stable, and comparison-based sorting algorithm. Most implementations produce a stable sort, meaning that the order of equal elements is the same in the input and output. It works by recursively splitting the list into two halves, sorting each half, and then merging the sorted halves back together."},fr:{title:"Merge Sort",timeComplexity:"Temps : O(n log n)",spaceComplexity:"Espace : O(n)",description:"Le tri fusion est un algorithme de tri efficace, stable et bas\xe9 sur la comparaison. La plupart des impl\xe9mentations produisent un tri stable, ce qui signifie que l'ordre des \xe9l\xe9ments \xe9gaux est le m\xeame dans l'entr\xe9e et la sortie. Il fonctionne en divisant r\xe9cursivement la liste en deux moiti\xe9s, en triant chaque moiti\xe9, puis en fusionnant les moiti\xe9s tri\xe9es."},it:{title:"Merge Sort",timeComplexity:"Tempo: O(n log n)",spaceComplexity:"Spazio: O(n)",description:"Il merge sort \xe8 un algoritmo di ordinamento efficiente, stabile e basato sul confronto. La maggior parte delle implementazioni produce un ordinamento stabile, il che significa che l'ordine degli elementi uguali \xe8 lo stesso nell'input e nell'output. Funziona dividendo ricorsivamente la lista in due met\xe0, ordinando ciascuna met\xe0 e poi unendo le met\xe0 ordinate."},de:{title:"Merge Sort",timeComplexity:"Zeit: O(n log n)",spaceComplexity:"Platz: O(n)",description:"Mergesort ist ein effizienter, stabiler und vergleichsbasierter Sortieralgorithmus. Die meisten Implementierungen produzieren eine stabile Sortierung, was bedeutet, dass die Reihenfolge der gleichen Elemente im Eingabedaten und Ausgabedaten gleich ist. Es funktioniert, indem die Liste rekursiv in zwei H\xe4lften geteilt wird, jede H\xe4lfte sortiert und dann die sortierten H\xe4lften wieder zusammengef\xfchrt werden."},es:{title:"Merge Sort",timeComplexity:"Tiempo: O(n log n)",spaceComplexity:"Espacio: O(n)",description:"El mergesort es un algoritmo de ordenamiento eficiente, estable y basado en comparaciones. La mayor\xeda de las implementaciones producen un ordenamiento estable, lo que significa que el orden de los elementos iguales es el mismo en la entrada y en la salida. Funciona dividiendo recursivamente la lista en dos mitades, ordenando cada mitad y luego fusionando las mitades ordenadas."},ja:{title:"Merge Sort",timeComplexity:"時間: O(n log n)",spaceComplexity:"空間: O(n)",description:"マージソートは、効率的で安定した比較ベースのソートアルゴリズムです。ほとんどの実装は安定したソートを生成し、入力と出力で同じ要素の順序が同じになります。リストを再帰的に2つの半分に分割し、それぞれをソートしてからソートされた半分を再度マージすることで動作します。"},no:{title:"Merge Sort",timeComplexity:"Tid: O(n log n)",spaceComplexity:"Plass: O(n)",description:"Merge sort er en effektiv, stabil og sammenligningsbasert sorteringsalgoritme. De fleste implementeringer produserer en stabil sortering, noe som betyr at rekkef\xf8lgen av like elementer er den samme i inn- og utdata. Den fungerer ved \xe5 rekursivt dele listen i to halvdeler, sortere hver halv og deretter sl\xe5 de sorterte halvdelene sammen igjen."},sv:{title:"Merge Sort",timeComplexity:"Tid: O(n log n)",spaceComplexity:"Utrymme: O(n)",description:"Merge sort \xe4r en effektiv, stabil och j\xe4mf\xf6relsebaserad sorteringsalgoritm. De flesta implementationer producerar en stabil sortering, vilket betyder att ordningen p\xe5 lika element \xe4r densamma i input och output. Det fungerar genom att rekursivt dela upp listan i tv\xe5 halvor, sortera varje halv och sedan sl\xe5 ihop de sorterade halvorna."},ua:{title:"Merge Sort",timeComplexity:"Час: O(n log n)",spaceComplexity:"Місце: O(n)",description:"Сортування злиттям - це ефективний, стабільний алгоритм сортування на основі порівнянь. Більшість реалізацій забезпечують стабільне сортування, що означає, що порядок однакових елементів однаковий на вході та на виході. Він працює, рекурсивно розділяючи список на дві половини, сортує кожну половину, а потім зливає відсортовані половини разом."},ru:{title:"Merge Sort",timeComplexity:"Время: O(n log n)",spaceComplexity:"Место: O(n)",description:"Сортировка слиянием - это эффективный, стабильный и основанный на сравнениях алгоритм сортировки. Большинство реализаций обеспечивают стабильную сортировку, что означает, что порядок одинаковых элементов на входе и на выходе одинаков. Он работает, рекурсивно разделяя список на две половины, сортируя каждую половину, а затем объединяя отсортированные половины вместе."}},heap:{en:{title:"Heap Sort",timeComplexity:"Time: O(n log n)",spaceComplexity:"Space: O(1)",description:"Heap sort is a comparison-based sorting algorithm that uses a binary heap data structure. It divides its input into a sorted and an unsorted region, and it iteratively shrinks the unsorted region by extracting the largest element and moving it to the sorted region."},fr:{title:"Heap Sort",timeComplexity:"Temps : O(n log n)",spaceComplexity:"Espace : O(1)",description:"Le tri par tas est un algorithme de tri bas\xe9 sur la comparaison qui utilise une structure de donn\xe9es de tas binaire. Il divise son entr\xe9e en une r\xe9gion tri\xe9e et une r\xe9gion non tri\xe9e, et il r\xe9duit de mani\xe8re it\xe9rative la r\xe9gion non tri\xe9e en extrayant le plus grand \xe9l\xe9ment et en le d\xe9pla\xe7ant vers la r\xe9gion tri\xe9e."},it:{title:"Heap Sort",timeComplexity:"Tempo: O(n log n)",spaceComplexity:"Spazio: O(1)",description:"L'heapsort \xe8 un algoritmo di ordinamento basato sul confronto che utilizza una struttura dati heap binaria. Divide il suo input in una regione ordinata e una non ordinata e riduce iterativamente la regione non ordinata estraendo l'elemento pi\xf9 grande e spostandolo nella regione ordinata."},de:{title:"Heap Sort",timeComplexity:"Zeit: O(n log n)",spaceComplexity:"Platz: O(1)",description:"Heapsort ist ein vergleichsbasierter Sortieralgorithmus, der eine bin\xe4re Heap-Datenstruktur verwendet. Es teilt seine Eingabe in einen sortierten und einen unsortierten Bereich und verkleinert den unsortierten Bereich iterativ, indem das gr\xf6\xdfte Element extrahiert und in den sortierten Bereich verschoben wird."},es:{title:"Heap Sort",timeComplexity:"Tiempo: O(n log n)",spaceComplexity:"Espacio: O(1)",description:"El heapsort es un algoritmo de ordenamiento basado en comparaciones que utiliza una estructura de datos de mont\xf3n binario. Divide su entrada en una regi\xf3n ordenada y una no ordenada, y reduce iterativamente la regi\xf3n no ordenada extrayendo el elemento m\xe1s grande y movi\xe9ndolo a la regi\xf3n ordenada."},ja:{title:"Heap Sort",timeComplexity:"時間: O(n log n)",spaceComplexity:"空間: O(1)",description:"ヒープソートは、バイナリヒープデータ構造を使用する比較ベースのソートアルゴリズムです。入力をソート済みと未ソートの領域に分割し、最も大きな要素を抽出してソート済み領域に移動することで未ソート領域を反復的に縮小します。"},no:{title:"Heap Sort",timeComplexity:"Tid: O(n log n)",spaceComplexity:"Plass: O(1)",description:"Heap sort er en sammenligningsbasert sorteringsalgoritme som bruker en bin\xe6r heap-datastruktur. Den deler inn dataene i et sortert og et usortert omr\xe5de, og krymper det usorterte omr\xe5det iterativt ved \xe5 trekke ut det st\xf8rste elementet og flytte det til det sorterte omr\xe5det."},sv:{title:"Heap Sort",timeComplexity:"Tid: O(n log n)",spaceComplexity:"Utrymme: O(1)",description:"Heap sort \xe4r en j\xe4mf\xf6relsebaserad sorteringsalgoritm som anv\xe4nder en bin\xe4r heap-datastruktur. Den delar upp sin input i en sorterad och en osorterad region, och krymper iterativt den osorterade regionen genom att extrahera det st\xf6rsta elementet och flytta det till den sorterade regionen."},ua:{title:"Heap Sort",timeComplexity:"Час: O(n log n)",spaceComplexity:"Місце: O(1)",description:"Сортування купою - це алгоритм сортування на основі порівнянь, який використовує структуру даних бінарної купи. Він ділить свій вхід на відсортовану та невідсортовану область і ітеративно зменшує невідсортовану область, витягуючи найбільший елемент і переміщуючи його до відсортованої області."},ru:{title:"Heap Sort",timeComplexity:"Время: O(n log n)",spaceComplexity:"Место: O(1)",description:"Сортировка кучей - это алгоритм сортировки на основе сравнений, который использует структуру данных бинарной кучи. Он делит свой вход на отсортированную и неотсортированную область и итеративно сокращает неотсортированную область, извлекая наибольший элемент и перемещая его в отсортированную область."}},quick:{en:{title:"Quick Sort",timeComplexity:"Time: O(n log n) on average, O(n^2) in the worst case",spaceComplexity:"Space: O(log n)",description:"Quick sort is an efficient sorting algorithm that uses a divide-and-conquer approach to sort elements. It works by selecting a 'pivot' element from the array and partitioning the other elements into two sub-arrays according to whether they are less than or greater than the pivot. The sub-arrays are then sorted recursively."},fr:{title:"Quick Sort",timeComplexity:"Temps : O(n log n) en moyenne, O(n^2) dans le pire des cas",spaceComplexity:"Espace : O(log n)",description:"Le tri rapide est un algorithme de tri efficace qui utilise une approche de diviser pour mieux r\xe9gner pour trier les \xe9l\xe9ments. Il fonctionne en s\xe9lectionnant un \xe9l\xe9ment 'pivot' dans le tableau et en partitionnant les autres \xe9l\xe9ments en deux sous-tableaux selon qu'ils sont inf\xe9rieurs ou sup\xe9rieurs au pivot. Les sous-tableaux sont ensuite tri\xe9s de mani\xe8re r\xe9cursive."},it:{title:"Quick Sort",timeComplexity:"Tempo: O(n log n) in media, O(n^2) nel peggiore dei casi",spaceComplexity:"Spazio: O(log n)",description:"Il quick sort \xe8 un algoritmo di ordinamento efficiente che utilizza un approccio divide et impera per ordinare gli elementi. Funziona selezionando un elemento 'pivot' dall'array e partizionando gli altri elementi in due sotto-array a seconda che siano inferiori o superiori al pivot. I sotto-array vengono poi ordinati ricorsivamente."},de:{title:"Quick Sort",timeComplexity:"Zeit: O(n log n) im Durchschnitt, O(n^2) im schlimmsten Fall",spaceComplexity:"Platz: O(log n)",description:"Quicksort ist ein effizienter Sortieralgorithmus, der einen Divide-and-Conquer-Ansatz verwendet, um Elemente zu sortieren. Es funktioniert, indem ein 'Pivot'-Element aus dem Array ausgew\xe4hlt und die anderen Elemente in zwei Unterarrays partitioniert werden, je nachdem, ob sie kleiner oder gr\xf6\xdfer als das Pivot sind. Die Unterarrays werden dann rekursiv sortiert."},es:{title:"Quick Sort",timeComplexity:"Tiempo: O(n log n) en promedio, O(n^2) en el peor de los casos",spaceComplexity:"Espacio: O(log n)",description:"El quicksort es un algoritmo de ordenamiento eficiente que utiliza un enfoque de divide y vencer\xe1s para ordenar los elementos. Funciona seleccionando un elemento 'pivote' del array y particionando los otros elementos en dos sub-arrays seg\xfan si son menores o mayores que el pivote. Los sub-arrays se ordenan luego recursivamente."},ja:{title:"Quick Sort",timeComplexity:"時間: 平均O(n log n)、最悪O(n^2)",spaceComplexity:"空間: O(log n)",description:"クイックソートは、要素をソートするために分割統治法を使用する効率的なソートアルゴリズムです。配列から「ピボット」要素を選択し、他の要素をピボットより小さいか大きいかによって2つのサブ配列に分割することで機能します。サブ配列は再帰的にソートされます。"},no:{title:"Quick Sort",timeComplexity:"Tid: O(n log n) i gjennomsnitt, O(n^2) i verste fall",spaceComplexity:"Plass: O(log n)",description:"Quick sort er en effektiv sorteringsalgoritme som bruker en del og hersk-tiln\xe6rming for \xe5 sortere elementer. Den fungerer ved \xe5 velge et 'pivot'-element fra matrisen og partisjonere de andre elementene i to underarrayer i henhold til om de er mindre enn eller st\xf8rre enn pivot. Underarrayene sorteres deretter rekursivt."},sv:{title:"Quick Sort",timeComplexity:"Tid: O(n log n) i genomsnitt, O(n^2) i v\xe4rsta fall",spaceComplexity:"Utrymme: O(log n)",description:"Quick sort \xe4r en effektiv sorteringsalgoritm som anv\xe4nder en dela-och-h\xe4rska-metod f\xf6r att sortera element. Det fungerar genom att v\xe4lja ett 'pivot'-element fr\xe5n matrisen och partitionera de andra elementen i tv\xe5 underarrayer beroende p\xe5 om de \xe4r mindre \xe4n eller st\xf6rre \xe4n pivot. Underarrayerna sorteras sedan rekursivt."},ua:{title:"Quick Sort",timeComplexity:"Час: O(n log n) в середньому, O(n^2) в гіршому випадку",spaceComplexity:"Місце: O(log n)",description:"Швидке сортування - це ефективний алгоритм сортування, який використовує підхід поділу і завоювання для сортування елементів. Він працює, вибираючи 'опорний' елемент з масиву і розділяючи інші елементи на два підмасиви відповідно до того, чи менші вони або більші за опорний. Підмасиви потім сортуються рекурсивно."},ru:{title:"Quick Sort",timeComplexity:"Время: O(n log n) в среднем, O(n^2) в худшем случае",spaceComplexity:"Место: O(log n)",description:"Быстрая сортировка - это эффективный алгоритм сортировки, который использует подход разделяй и властвуй для сортировки элементов. Он работает, выбирая 'опорный' элемент из массива и разделяя другие элементы на два подмассива в зависимости от того, меньше они или больше опорного. Подмассивы затем сортируются рекурсивно."}},radix:{en:{title:"Radix Sort",timeComplexity:"Time: O(nk) where n is the number of elements and k is the number of digits in the largest number",spaceComplexity:"Space: O(n + k)",description:"Radix Sort is a non-comparative sorting algorithm that sorts integers by processing individual digits. It processes each digit from the least significant to the most significant, using a stable counting sort to sort digits at each level."},fr:{title:"Tri Radix",timeComplexity:"Temps : O(nk) o\xf9 n est le nombre d'\xe9l\xe9ments et k est le nombre de chiffres du plus grand nombre",spaceComplexity:"Espace : O(n + k)",description:"Le tri Radix est un algorithme de tri non comparatif qui trie les entiers en traitant les chiffres individuels. Il traite chaque chiffre du moins significatif au plus significatif, en utilisant un tri comptant stable pour trier les chiffres \xe0 chaque niveau."},it:{title:"Radix Sort",timeComplexity:"Tempo: O(nk) dove n \xe8 il numero di elementi e k \xe8 il numero di cifre nel numero pi\xf9 grande",spaceComplexity:"Spazio: O(n + k)",description:"Il Radix Sort \xe8 un algoritmo di ordinamento non comparativo che ordina gli interi elaborando le singole cifre. Elabora ciascuna cifra dal meno significativo al pi\xf9 significativo, utilizzando un ordinamento per conteggio stabile per ordinare le cifre a ciascun livello."},de:{title:"Radix Sort",timeComplexity:"Zeit: O(nk), wobei n die Anzahl der Elemente und k die Anzahl der Ziffern der gr\xf6\xdften Zahl ist",spaceComplexity:"Platz: O(n + k)",description:"Radix Sort ist ein nicht-vergleichender Sortieralgorithmus, der Ganzzahlen durch Verarbeitung einzelner Ziffern sortiert. Er verarbeitet jede Ziffer von der am wenigsten signifikanten zur am meisten signifikanten und verwendet ein stabiles Z\xe4hlersortieren, um die Ziffern auf jeder Ebene zu sortieren."},es:{title:"Radix Sort",timeComplexity:"Tiempo: O(nk) donde n es el n\xfamero de elementos y k es el n\xfamero de d\xedgitos en el n\xfamero m\xe1s grande",spaceComplexity:"Espacio: O(n + k)",description:"El Radix Sort es un algoritmo de ordenamiento no comparativo que ordena enteros procesando d\xedgitos individuales. Procesa cada d\xedgito desde el menos significativo hasta el m\xe1s significativo, utilizando un conteo estable para ordenar los d\xedgitos en cada nivel."},ja:{title:"基数ソート",timeComplexity:"時間: O(nk) ここで n は要素数、k は最大数の桁数",spaceComplexity:"空間: O(n + k)",description:"基数ソートは、個々の数字を処理することで整数をソートする非比較ソートアルゴリズムです。各桁を最下位から最上位まで処理し、安定したカウントソートを使用して各レベルの桁をソートします。"},no:{title:"Radix Sort",timeComplexity:"Tid: O(nk) der n er antall elementer og k er antall sifre i det st\xf8rste tallet",spaceComplexity:"Plass: O(n + k)",description:"Radix Sort er en ikke-sammenlignende sorteringsalgoritme som sorterer heltall ved \xe5 behandle individuelle sifre. Den behandler hvert siffer fra minst signifikant til mest signifikant, og bruker en stabil tellesortering for \xe5 sortere sifrene p\xe5 hvert niv\xe5."},sv:{title:"Radix Sort",timeComplexity:"Tid: O(nk) d\xe4r n \xe4r antalet element och k \xe4r antalet siffror i det st\xf6rsta numret",spaceComplexity:"Utrymme: O(n + k)",description:"Radix Sort \xe4r en icke-j\xe4mf\xf6rande sorteringsalgoritm som sorterar heltal genom att bearbeta individuella siffror. Den bearbetar varje siffra fr\xe5n minst signifikant till mest signifikant, med en stabil r\xe4kningssortering f\xf6r att sortera siffrorna p\xe5 varje niv\xe5."},ua:{title:"Радикс Сортування",timeComplexity:"Час: O(nk), де n - кількість елементів, а k - кількість цифр у найбільшому числі",spaceComplexity:"Місце: O(n + k)",description:"Радикс сортування - це алгоритм сортування без порівняння, який сортує цілі числа, обробляючи окремі цифри. Він обробляє кожну цифру від найменш значущої до найбільш значущої, використовуючи стабільне підрахункове сортування для сортування цифр на кожному рівні."},ru:{title:"Поразрядная сортировка",timeComplexity:"Время: O(nk), где n - количество элементов, а k - количество цифр в наибольшем числе",spaceComplexity:"Место: O(n + k)",description:"Поразрядная сортировка - это не сравнительный алгоритм сортировки, который сортирует целые числа путем обработки отдельных цифр. Он обрабатывает каждую цифру от наименее значимой до наиболее значимой, используя стабильную сортировку подсчетом для сортировки цифр на каждом уровне."}},counting:{en:{title:"Counting Sort",timeComplexity:"Time: O(n + k) where n is the number of elements and k is the range of the input",spaceComplexity:"Space: O(k)",description:"Counting Sort is a non-comparative sorting algorithm that works by counting the number of occurrences of each distinct element in the input. The count is then used to place the elements in the correct position in the output array."},fr:{title:"Tri par d\xe9nombrement",timeComplexity:"Temps : O(n + k) o\xf9 n est le nombre d'\xe9l\xe9ments et k est la plage de l'entr\xe9e",spaceComplexity:"Espace : O(k)",description:"Le tri par d\xe9nombrement est un algorithme de tri non comparatif qui fonctionne en comptant le nombre d'occurrences de chaque \xe9l\xe9ment distinct dans l'entr\xe9e. Le compte est ensuite utilis\xe9 pour placer les \xe9l\xe9ments dans la position correcte dans le tableau de sortie."},it:{title:"Counting Sort",timeComplexity:"Tempo: O(n + k) dove n \xe8 il numero di elementi e k \xe8 l'intervallo dell'input",spaceComplexity:"Spazio: O(k)",description:"Il Counting Sort \xe8 un algoritmo di ordinamento non comparativo che funziona contando il numero di occorrenze di ciascun elemento distinto nell'input. Il conteggio viene quindi utilizzato per posizionare gli elementi nella posizione corretta nell'array di output."},de:{title:"Counting Sort",timeComplexity:"Zeit: O(n + k), wobei n die Anzahl der Elemente und k der Bereich der Eingabe ist",spaceComplexity:"Platz: O(k)",description:"Counting Sort ist ein nicht-vergleichender Sortieralgorithmus, der funktioniert, indem die Anzahl der Vorkommen jedes einzelnen Elements in der Eingabe gez\xe4hlt wird. Die Z\xe4hlung wird dann verwendet, um die Elemente an der richtigen Position im Ausgabearray zu platzieren."},es:{title:"Counting Sort",timeComplexity:"Tiempo: O(n + k) donde n es el n\xfamero de elementos y k es el rango de la entrada",spaceComplexity:"Espacio: O(k)",description:"Counting Sort es un algoritmo de ordenamiento no comparativo que funciona contando el n\xfamero de ocurrencias de cada elemento distinto en la entrada. Luego, el conteo se utiliza para colocar los elementos en la posici\xf3n correcta en la matriz de salida."},ja:{title:"計数ソート",timeComplexity:"時間: O(n + k) ここで n は要素数、k は入力範囲",spaceComplexity:"空間: O(k)",description:"計数ソートは、入力内の各異なる要素の出現回数をカウントすることで機能する非比較ソートアルゴリズムです。次に、カウントを使用して、要素を出力配列の正しい位置に配置します。"},no:{title:"Counting Sort",timeComplexity:"Tid: O(n + k) der n er antall elementer og k er omr\xe5det for inngangen",spaceComplexity:"Plass: O(k)",description:"Counting Sort er en ikke-sammenlignende sorteringsalgoritme som fungerer ved \xe5 telle antall forekomster av hvert distinkte element i inngangen. Deretter brukes tellingen til \xe5 plassere elementene i riktig posisjon i utgangsmatrisen."},sv:{title:"Counting Sort",timeComplexity:"Tid: O(n + k) d\xe4r n \xe4r antalet element och k \xe4r inmatningsomr\xe5det",spaceComplexity:"Utrymme: O(k)",description:"Counting Sort \xe4r en icke-j\xe4mf\xf6rande sorteringsalgoritm som fungerar genom att r\xe4kna antalet f\xf6rekomster av varje distinkt element i ing\xe5ngen. Sedan anv\xe4nds r\xe4kningen f\xf6r att placera elementen i r\xe4tt position i utmatningsmatrisen."},ua:{title:"Підрахункове сортування",timeComplexity:"Час: O(n + k), де n - кількість елементів, а k - діапазон введення",spaceComplexity:"Місце: O(k)",description:"Підрахункове сортування - це алгоритм сортування без порівняння, який працює шляхом підрахунку кількості появ кожного окремого елемента у вхідних даних. Потім підрахунок використовується для розміщення елементів у правильній позиції у вихідному масиві."},ru:{title:"Сортировка подсчетом",timeComplexity:"Время: O(n + k), где n - количество элементов, а k - диапазон входных данных",spaceComplexity:"Место: O(k)",description:"Сортировка подсчетом - это не сравнительный алгоритм сортировки, который работает путем подсчета количества вхождений каждого отдельного элемента во входных данных. Затем подсчет используется для размещения элементов в правильной позиции в выходном массиве."}},bucket:{en:{title:"Bucket Sort",timeComplexity:"Time: O(n + k) where n is the number of elements and k is the number of buckets",spaceComplexity:"Space: O(n + k)",description:"Bucket Sort is a sorting algorithm that works by distributing the elements of an array into a number of buckets. Each bucket is then sorted individually, either using a different sorting algorithm or recursively applying the bucket sort."},fr:{title:"Tri par compartiments",timeComplexity:"Temps : O(n + k) o\xf9 n est le nombre d'\xe9l\xe9ments et k est le nombre de compartiments",spaceComplexity:"Espace : O(n + k)",description:"Le tri par compartiments est un algorithme de tri qui fonctionne en distribuant les \xe9l\xe9ments d'un tableau dans un certain nombre de compartiments. Chaque compartiment est ensuite tri\xe9 individuellement, soit en utilisant un autre algorithme de tri, soit en appliquant r\xe9cursivement le tri par compartiments."},it:{title:"Bucket Sort",timeComplexity:"Tempo: O(n + k) dove n \xe8 il numero di elementi e k \xe8 il numero di bucket",spaceComplexity:"Spazio: O(n + k)",description:"Il Bucket Sort \xe8 un algoritmo di ordinamento che funziona distribuendo gli elementi di un array in un certo numero di bucket. Ogni bucket viene quindi ordinato singolarmente, utilizzando un altro algoritmo di ordinamento o applicando ricorsivamente il bucket sort."},de:{title:"Bucket Sort",timeComplexity:"Zeit: O(n + k), wobei n die Anzahl der Elemente und k die Anzahl der Buckets ist",spaceComplexity:"Platz: O(n + k)",description:"Bucket Sort ist ein Sortieralgorithmus, der funktioniert, indem die Elemente eines Arrays auf eine Anzahl von Buckets verteilt werden. Jeder Bucket wird dann einzeln sortiert, entweder unter Verwendung eines anderen Sortieralgorithmus oder durch rekursive Anwendung des Bucket-Sortiers."},es:{title:"Bucket Sort",timeComplexity:"Tiempo: O(n + k) donde n es el n\xfamero de elementos y k es el n\xfamero de cubetas",spaceComplexity:"Espacio: O(n + k)",description:"El Bucket Sort es un algoritmo de ordenamiento que funciona distribuyendo los elementos de un array en un n\xfamero de cubetas. Cada cubeta se ordena individualmente, ya sea utilizando otro algoritmo de ordenamiento o aplicando recursivamente el bucket sort."},ja:{title:"バケットソート",timeComplexity:"時間: O(n + k) ここで n は要素数、k はバケットの数",spaceComplexity:"空間: O(n + k)",description:"バケットソートは、配列の要素を複数のバケットに分配することで機能するソートアルゴリズムです。各バケットは、他のソートアルゴリズムを使用するか、バケットソートを再帰的に適用して個別にソートされます。"},no:{title:"Bucket Sort",timeComplexity:"Tid: O(n + k) der n er antall elementer og k er antall b\xf8tter",spaceComplexity:"Plass: O(n + k)",description:"Bucket Sort er en sorteringsalgoritme som fungerer ved \xe5 fordele elementene i en matrise i et antall b\xf8tter. Hver b\xf8tte sorteres deretter individuelt, enten ved \xe5 bruke en annen sorteringsalgoritme eller ved \xe5 bruke bucket sort rekursivt."},sv:{title:"Bucket Sort",timeComplexity:"Tid: O(n + k) d\xe4r n \xe4r antalet element och k \xe4r antalet hinkar",spaceComplexity:"Utrymme: O(n + k)",description:"Bucket Sort \xe4r en sorteringsalgoritm som fungerar genom att distribuera elementen i en array i ett antal hinkar. Varje hink sorteras sedan individuellt, antingen med en annan sorteringsalgoritm eller genom att rekursivt till\xe4mpa bucket sort."},ua:{title:"Сортування по кошиках",timeComplexity:"Час: O(n + k), де n - кількість елементів, а k - кількість кошиків",spaceComplexity:"Місце: O(n + k)",description:"Сортування по кошиках - це алгоритм сортування, який працює шляхом розподілу елементів масиву на кілька кошиків. Кожен кошик потім сортується окремо, або за допомогою іншого алгоритму сортування, або рекурсивно застосовуючи сортування по кошиках."},ru:{title:"Сортировка по карманам",timeComplexity:"Время: O(n + k), где n - количество элементов, а k - количество карманов",spaceComplexity:"Место: O(n + k)",description:"Сортировка по карманам - это алгоритм сортировки, который работает путем распределения элементов массива по ряду карманов. Каждый карман затем сортируется отдельно, либо с использованием другого алгоритма сортировки, либо рекурсивным применением сортировки по карманам."}},shell:{en:{title:"Shell Sort",timeComplexity:"Time: O(n^2) in the worst case, but can be much better with a good gap sequence",spaceComplexity:"Space: O(1)",description:"Shell Sort is an in-place comparison sort that generalizes insertion sort to allow the exchange of items that are far apart. The algorithm starts by sorting pairs of elements far apart from each other, then progressively reducing the gap between elements to be compared."},fr:{title:"Tri de Shell",timeComplexity:"Temps : O(n^2) dans le pire des cas, mais peut \xeatre bien meilleur avec une bonne s\xe9quence de gaps",spaceComplexity:"Espace : O(1)",description:"Le tri de Shell est un tri par comparaison en place qui g\xe9n\xe9ralise le tri par insertion pour permettre l'\xe9change d'\xe9l\xe9ments \xe9loign\xe9s les uns des autres. L'algorithme commence par trier des paires d'\xe9l\xe9ments \xe9loign\xe9s les uns des autres, puis r\xe9duit progressivement l'\xe9cart entre les \xe9l\xe9ments \xe0 comparer."},it:{title:"Shell Sort",timeComplexity:"Tempo: O(n^2) nel peggiore dei casi, ma pu\xf2 essere molto migliore con una buona sequenza di gap",spaceComplexity:"Spazio: O(1)",description:"Il Shell Sort \xe8 un ordinamento in loco per confronto che generalizza l'ordinamento per inserzione per consentire lo scambio di elementi distanti tra loro. L'algoritmo inizia ordinando coppie di elementi distanti tra loro, quindi riduce progressivamente la distanza tra gli elementi da confrontare."},de:{title:"Shell Sort",timeComplexity:"Zeit: O(n^2) im schlimmsten Fall, kann aber mit einer guten Gap-Sequenz viel besser sein",spaceComplexity:"Platz: O(1)",description:"Shell Sort ist ein In-Place-Vergleichssortieralgorithmus, der den Insertionssort verallgemeinert, um den Austausch von Elementen zu erm\xf6glichen, die weit voneinander entfernt sind. Der Algorithmus beginnt mit dem Sortieren von Paaren von Elementen, die weit voneinander entfernt sind, und reduziert dann nach und nach den Abstand zwischen den zu vergleichenden Elementen."},es:{title:"Shell Sort",timeComplexity:"Tiempo: O(n^2) en el peor de los casos, pero puede ser mucho mejor con una buena secuencia de intervalos",spaceComplexity:"Espacio: O(1)",description:"El Shell Sort es un ordenamiento in situ por comparaci\xf3n que generaliza el ordenamiento por inserci\xf3n para permitir el intercambio de elementos que est\xe1n muy separados. El algoritmo comienza ordenando pares de elementos muy separados entre s\xed, y luego reduce progresivamente el intervalo entre los elementos a comparar."},ja:{title:"シェルソート",timeComplexity:"時間: 最悪の場合 O(n^2) ですが、適切なギャップシーケンスを使用すると大幅に改善できます",spaceComplexity:"空間: O(1)",description:"シェルソートは、離れた項目の交換を可能にする挿入ソートを一般化したインプレース比較ソートです。このアルゴリズムは、互いに遠く離れた要素のペアをソートすることから始まり、比較する要素間のギャップを徐々に減らしていきます。"},no:{title:"Shell Sort",timeComplexity:"Tid: O(n^2) i verste fall, men kan v\xe6re mye bedre med en god gapsekvens",spaceComplexity:"Plass: O(1)",description:"Shell Sort er en in-place sammenligningssortering som generaliserer innsettingssortering for \xe5 tillate bytte av elementer som er langt fra hverandre. Algoritmen starter med \xe5 sortere par av elementer langt fra hverandre, og reduserer deretter gradvis gapet mellom elementene som skal sammenlignes."},sv:{title:"Shell Sort",timeComplexity:"Tid: O(n^2) i v\xe4rsta fall, men kan vara mycket b\xe4ttre med en bra gapsekvens",spaceComplexity:"Utrymme: O(1)",description:"Shell Sort \xe4r en in-place-j\xe4mf\xf6relsesortering som generaliserar ins\xe4ttningssortering f\xf6r att m\xf6jligg\xf6ra byte av objekt som \xe4r l\xe5ngt ifr\xe5n varandra. Algoritmen b\xf6rjar med att sortera par av element l\xe5ngt ifr\xe5n varandra och minskar sedan successivt gapet mellan elementen som ska j\xe4mf\xf6ras."},ua:{title:"Сортування Шелла",timeComplexity:"Час: O(n^2) у найгіршому випадку, але може бути набагато кращим із хорошою послідовністю проміжків",spaceComplexity:"Місце: O(1)",description:"Сортування Шелла - це порівняльне сортування на місці, яке узагальнює сортування вставками, щоб дозволити обмін елементами, які знаходяться далеко один від одного. Алгоритм починає з сортування пар елементів, які знаходяться далеко один від одного, а потім поступово зменшує проміжок між елементами для порівняння."},ru:{title:"Сортировка Шелла",timeComplexity:"Время: O(n^2) в худшем случае, но может быть намного лучше с хорошей последовательностью промежутков",spaceComplexity:"Место: O(1)",description:"Сортировка Шелла - это сортировка на месте методом сравнения, которая обобщает сортировку вставками, чтобы позволить обмен элементами, которые находятся далеко друг от друга. Алгоритм начинается с сортировки пар элементов, находящихся далеко друг от друга, затем постепенно уменьшает разрыв между сравниваемыми элементами."}}};function D(){let[e,t]=(0,r.useState)([]),[i,a]=(0,r.useState)(!1),[o,s]=(0,r.useState)("bubble"),[l,d]=(0,r.useState)(20),[m,p]=(0,r.useState)("en"),u=(0,r.useRef)(!1),g=(0,r.useRef)(!1);(0,r.useEffect)(()=>{f(l)},[l]);let f=e=>{t(Array.from({length:e},()=>Math.floor(100*Math.random())))},k=async()=>(u.current&&await new Promise(e=>{let t=()=>{u.current&&!g.current?setTimeout(t,50):e(null)};t()}),g.current),T=async()=>{let i=[...e];for(let e=0;e<i.length;e++)for(let n=0;n<i.length-e-1;n++){if(await k())return;i[n]>i[n+1]&&([i[n],i[n+1]]=[i[n+1],i[n]],t([...i]),await new Promise(e=>setTimeout(e,50)))}g.current||a(!1)},z=async()=>{let i=[...e];for(let e=1;e<i.length;e++){if(await k())return;let n=i[e],r=e-1;for(;r>=0&&i[r]>n;){if(await k())return;i[r+1]=i[r],r-=1,t([...i]),await new Promise(e=>setTimeout(e,50))}i[r+1]=n,t([...i]),await new Promise(e=>setTimeout(e,50))}g.current||a(!1)};async function I(e,i,n){if(await k())return;let r=n,a=2*n+1,o=2*n+2;a<i&&e[a]>e[r]&&(r=a),o<i&&e[o]>e[r]&&(r=o),r!==n&&([e[n],e[r]]=[e[r],e[n]],t([...e]),await new Promise(e=>setTimeout(e,50)),await I(e,i,r))}let A=async()=>{let i=[...e],n=i.length;for(let e=Math.floor(n/2)-1;e>=0;e--){if(await k())return;await I(i,n,e)}for(let e=n-1;e>0;e--){if(await k())return;[i[0],i[e]]=[i[e],i[0]],t([...i]),await new Promise(e=>setTimeout(e,50)),await I(i,e,0)}g.current||a(!1)};async function D(e,i,n){if(await k())return i;let r=e[n],a=i-1;for(let o=i;o<n;o++){if(await k())return a+1;e[o]<r&&(a++,[e[a],e[o]]=[e[o],e[a]],t([...e]),await new Promise(e=>setTimeout(e,50)))}return[e[a+1],e[n]]=[e[n],e[a+1]],t([...e]),await new Promise(e=>setTimeout(e,50)),a+1}let Q=async(e,t,i)=>{if(t<i){if(await k())return;let n=await D(e,t,i);await Q(e,t,n-1),await Q(e,n+1,i)}},V=async(e,t,i)=>{if(!await k()&&t<i){let n=Math.floor((t+i)/2);await V(e,t,n),await V(e,n+1,i),await W(e,t,n,i)}},W=async(e,i,n,r)=>{if(await k())return;let a=n-i+1,o=r-n,s=Array(a),l=Array(o);for(let t=0;t<a;t++)s[t]=e[i+t];for(let t=0;t<o;t++)l[t]=e[n+1+t];let d=0,m=0,c=i;for(;d<a&&m<o;){if(await k())return;s[d]<=l[m]?(e[c]=s[d],d++):(e[c]=l[m],m++),t([...e]),await new Promise(e=>setTimeout(e,50)),c++}for(;d<a;){if(await k())return;e[c]=s[d],d++,c++,t([...e]),await new Promise(e=>setTimeout(e,50))}for(;m<o;){if(await k())return;e[c]=l[m],m++,c++,t([...e]),await new Promise(e=>setTimeout(e,50))}},_=async()=>{let i=[...e],n=async(e,i)=>{let n=Array(e.length).fill(0),r=Array(10).fill(0);for(let t=0;t<e.length;t++){if(await k())return;r[Math.floor(e[t]/i)%10]++}for(let e=1;e<10;e++)r[e]+=r[e-1];for(let t=e.length-1;t>=0;t--){if(await k())return;n[r[Math.floor(e[t]/i)%10]-1]=e[t],r[Math.floor(e[t]/i)%10]--}for(let i=0;i<e.length;i++)e[i]=n[i],t([...e]),await new Promise(e=>setTimeout(e,50))},r=Math.max(...i);for(let e=1;Math.floor(r/e)>0;e*=10){if(await k())return;await n(i,e)}g.current||a(!1)},G=async()=>{let i=[...e],n=Math.max(...i),r=Math.min(...i),o=Array(n-r+1).fill(0),s=Array(i.length).fill(0);for(let e=0;e<i.length;e++){if(await k())return;o[i[e]-r]++}for(let e=1;e<o.length;e++)o[e]+=o[e-1];for(let e=i.length-1;e>=0;e--){if(await k())return;s[o[i[e]-r]-1]=i[e],o[i[e]-r]--}for(let e=0;e<i.length;e++)i[e]=s[e],t([...i]),await new Promise(e=>setTimeout(e,50));g.current||a(!1)},Y=async()=>{let i=[...e],n=Math.min(...i),r=Array.from({length:Math.floor((Math.max(...i)-n)/5)+1},()=>[]);for(let e=0;e<i.length;e++){if(await k())return;r[Math.floor((i[e]-n)/5)].push(i[e])}for(let e=0;e<r.length;e++){if(await k())return;r[e].sort((e,t)=>e-t)}let o=0;for(let e=0;e<r.length;e++)for(let n=0;n<r[e].length;n++){if(await k())return;i[o++]=r[e][n],t([...i]),await new Promise(e=>setTimeout(e,50))}g.current||a(!1)},J=async()=>{let i=[...e],n=i.length;for(let e=Math.floor(n/2);e>0;e=Math.floor(e/2))for(let r=e;r<n;r++){let n;if(await k())return;let a=i[r];for(n=r;n>=e&&i[n-e]>a;n-=e)i[n]=i[n-e],t([...i]),await new Promise(e=>setTimeout(e,50));i[n]=a,t([...i]),await new Promise(e=>setTimeout(e,50))}g.current||a(!1)},{title:K,timeComplexity:X,spaceComplexity:$,description:ee}=H[o][m]||H[o].en;return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)("div",{className:"flex flex-col items-center h-screen",children:[(0,n.jsx)("header",{className:"bg-primary text-primary-foreground py-4 px-6 w-full ",children:(0,n.jsx)("h1",{className:"text-4xl font-bold text-center",children:"Algorithm Visualizer"})}),(0,n.jsxs)("h1",{className:"text-3xl font-bold mt-8 capitalize",children:[o," sort"]}),(0,n.jsx)("div",{className:"flex items-end justify-center h-64 mt-10 shadow-2xl p-4 max-w-full",children:e.map((e,t)=>(0,n.jsx)("div",{className:"mx-0.5 ".concat(i?"bg-red-500":"bg-blue-500"),style:{height:"".concat(2*e,"px"),width:"20px"}},t))}),(0,n.jsxs)("div",{className:"flex mt-10 space-x-4",children:[(0,n.jsx)(c,{onClick:()=>{switch(a(!0),u.current=!1,g.current=!1,o){case"bubble":T();break;case"insertion":z();break;case"merge":V([...e],0,e.length-1);break;case"heap":A();break;case"quick":Q([...e],0,e.length-1);break;case"radix":_();break;case"counting":G();break;case"bucket":Y();break;case"shell":J()}},children:"Start"}),(0,n.jsx)(c,{onClick:()=>{u.current=!0},variant:"outline",children:"Pause"}),(0,n.jsx)(c,{onClick:()=>{u.current=!1},variant:"outline",children:"Resume"}),(0,n.jsx)(c,{onClick:()=>{a(!1),u.current=!1,g.current=!0,f(l)},children:"Reset"}),(0,n.jsx)(c,{onClick:()=>{t([...e].sort(()=>Math.random()-.5))},children:"Shuffle"}),(0,n.jsxs)(h,{children:[(0,n.jsx)(x,{asChild:!0,children:(0,n.jsxs)(c,{children:[o.charAt(0).toUpperCase()+o.slice(1)," Sort"]})}),(0,n.jsx)(b,{children:(0,n.jsxs)(y,{value:o,onValueChange:e=>s(e),children:[(0,n.jsx)(v,{value:"bubble",children:"Bubble Sort"}),(0,n.jsx)(v,{value:"insertion",children:"Insertion Sort"}),(0,n.jsx)(v,{value:"merge",children:"Merge Sort"}),(0,n.jsx)(v,{value:"heap",children:"Heap Sort"}),(0,n.jsx)(v,{value:"quick",children:"Quick Sort"}),(0,n.jsx)(v,{value:"radix",children:"Radix Sort"}),(0,n.jsx)(v,{value:"counting",children:"Counting Sort"}),(0,n.jsx)(v,{value:"bucket",children:"Bucket Sort"}),(0,n.jsx)(v,{value:"shell",children:"Shell Sort"})]})})]})]}),(0,n.jsxs)("div",{className:"flex flex-col items-center mt-10 space-y-4",children:[(0,n.jsxs)("label",{className:"text-xl",children:["Array Size: ",l]}),(0,n.jsx)(C,{value:[l],onValueChange:e=>d(e[0]),min:5,max:100})]}),(0,n.jsx)("div",{className:"mt-16 w-full max-w-xl",children:(0,n.jsxs)(O,{className:"shadow-2xl",children:[(0,n.jsxs)(w,{children:[(0,n.jsx)(S,{className:"underline mb-2",children:K}),(0,n.jsxs)(j,{children:[(0,n.jsx)("div",{children:X}),(0,n.jsx)("div",{children:$})]})]}),(0,n.jsx)(N,{children:(0,n.jsx)("p",{className:"text-justify",children:ee})})]})})]}),(0,n.jsx)("footer",{className:"bg-muted text-muted-foreground py-6",children:(0,n.jsxs)("div",{className:"container mx-auto px-4 md:px-6 flex items-center justify-between",children:[(0,n.jsx)("p",{className:"text-sm",children:"\xa9 2024 Quintavalle Pietro. All rights reserved."}),(0,n.jsxs)("nav",{className:"flex items-center gap-4",children:[(0,n.jsxs)(h,{children:[(0,n.jsx)(x,{asChild:!0,children:(0,n.jsx)(c,{variant:"outline",children:m.toUpperCase()})}),(0,n.jsx)(b,{children:(0,n.jsx)(y,{value:m,onValueChange:e=>p(e),children:L.map(e=>(0,n.jsx)(v,{value:e,children:e.toUpperCase()},e))})})]}),(0,n.jsxs)(E,{children:[(0,n.jsx)(R,{children:"Licence"}),(0,n.jsx)(q,{children:(0,n.jsxs)(P,{children:[(0,n.jsx)(M,{children:"MIT License"}),(0,n.jsxs)(B,{children:[(0,n.jsx)("p",{className:"font-bold",children:"Copyright (c) 2024 Quintavalle Pietro"}),(0,n.jsx)("p",{className:"mt-2",children:'Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:'}),(0,n.jsx)("p",{children:"The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software."}),(0,n.jsx)("p",{className:"mt-2",children:'THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.'})]})]})})]}),(0,n.jsx)("a",{href:"https://github.com/Quinta0",target:"_blank",rel:"noopener noreferrer",className:"hover:underline",children:(0,n.jsx)(U,{className:"w-6 h-6"})}),(0,n.jsx)("a",{href:"mailto:0pietroquintavalle0@gmail.com",className:"hover:underline",children:(0,n.jsx)(Z,{className:"w-6 h-6"})}),(0,n.jsx)("a",{href:"https://www.linkedin.com/in/pietro-quintavalle-996b96267/",target:"_blank",rel:"noopener noreferrer",className:"hover:underline",children:(0,n.jsx)(F,{className:"w-6 h-6"})})]})]})})]})}function U(e){return(0,n.jsx)("svg",{...e,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 24 24",fill:"currentColor",stroke:"currentColor",strokeWidth:"0",children:(0,n.jsx)("path",{d:"M12 .5C5.48.5.5 5.48.5 12c0 5.08 3.29 9.35 7.85 10.86.58.1.79-.24.79-.54 0-.27-.01-.99-.01-1.94-3.19.69-3.86-1.54-3.86-1.54-.53-1.36-1.29-1.72-1.29-1.72-1.05-.72.08-.71.08-.71 1.16.08 1.77 1.2 1.77 1.2 1.03 1.77 2.69 1.26 3.34.96.1-.75.4-1.26.73-1.55-2.55-.29-5.23-1.28-5.23-5.72 0-1.26.45-2.29 1.2-3.1-.12-.29-.52-1.45.12-3.02 0 0 .97-.31 3.17 1.18.92-.26 1.91-.39 2.89-.39.98 0 1.97.13 2.89.39 2.2-1.49 3.17-1.18 3.17-1.18.64 1.57.24 2.73.12 3.02.75.81 1.2 1.84 1.2 3.1 0 4.46-2.69 5.43-5.25 5.71.41.35.78 1.03.78 2.08 0 1.5-.01 2.72-.01 3.08 0 .3.21.65.8.54C20.71 21.35 24 17.08 24 12c0-6.52-4.98-11.5-12-11.5z"})})}function Z(e){return(0,n.jsx)("svg",{...e,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 24 24",fill:"currentColor",stroke:"currentColor",strokeWidth:"0",children:(0,n.jsx)("path",{d:"M12 12.713l11.985-8.677a.868.868 0 0 0-.491-.148H.506c-.177 0-.344.055-.491.148L12 12.713zm0 1.431L.035 5.596A.875.875 0 0 0 0 6.125v11.75c0 .478.387.875.875.875h22.25c.478 0 .875-.387.875-.875V6.125a.875.875 0 0 0-.035-.529L12 14.144z"})})}function F(e){return(0,n.jsx)("svg",{...e,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 24 24",fill:"currentColor",stroke:"currentColor",strokeWidth:"0",children:(0,n.jsx)("path",{d:"M19 0h-14c-2.761 0-5 2.239-5 5v14c0 2.761 2.239 5 5 5h14c2.761 0 5-2.239 5-5v-14c0-2.761-2.239-5-5-5zm-11 19h-3v-11h3v11zm-1.5-12.5c-.966 0-1.75-.784-1.75-1.75s.784-1.75 1.75-1.75 1.75.784 1.75 1.75-.784 1.75-1.75 1.75zm13.5 12.5h-3v-5.5c0-1.379-1.121-2.5-2.5-2.5s-2.5 1.121-2.5 2.5v5.5h-3v-11h3v1.474c.809-1.161 2.201-1.974 3.5-1.974 2.481 0 4.5 2.019 4.5 4.5v7z"})})}}},function(e){e.O(0,[57,971,23,744],function(){return e(e.s=5515)}),_N_E=e.O()}]);